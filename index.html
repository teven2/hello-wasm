<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WASM Example</title>
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link href="https://fonts.googleapis.com/css?family=Aldrich&display=swap" rel="stylesheet">
    <link href="styles.css" type="text/css" rel="stylesheet" media="screen" />
</head>

<body>
    <h1>WASM Examples</h1>
    <p>
        This is a small collection of <strong>wasm</strong> examples.
        Check out the console for output, as well as the div elements beneath each example
        (results loaded in these elements)
    </p>

    <!-- Example 1 -->
    <h2>Add two integers</h2>
    <div class="owasm" id="wasm_output_ex1"></div>
    <pre>
    ;;wasm
    (module
        (func (export "add") (param $n1 i32) (param $n2 i32) (result i32)
            get_local $n1
            get_local $n2
            i32.add
        )
    )     
    
    // in JS call it with:
    const iw = require('inline-webassembly');
    const wasm = `;;wasm
        your wasm code here
    `;
    iw(wasm).then((wasmModule) => {
        const sum = wasmModule.add(1, 2);
    });
    </pre>

<!-- Example 2 - Now with VISIBLE PIXELS! -->
<h2>2. Draw a colorful 256×256 pixel block (visible!)</h2>
<div class="owasm" id="wasm_output_ex2" style="width:256px; height:256px; image-rendering:pixelated; margin:1rem 0;">
  <canvas id="pixelCanvas" width="256" height="256" style="width:100%; height:auto; border:2px solid #58a6ff; border-radius:8px;"></canvas>
</div>

<pre>;;wasm
(module
  (memory (export "memory") 2)                  ;; 2 pages = 128 KiB → enough for 256×256×4 RGBA

  (func (export "drawPixels") (result i32)
    (local $i i32)
    (local $ptr i32)

    ;; Start writing at offset 0
    (set_local $ptr (i32.const 0))

    (block
      (loop
        ;; Stop after 256×256 pixels
        (br_if 1 (i32.ge_u (get_local $i) (i32.const 65536)))

        ;; Compute x = i % 256, y = i / 256
        (local.set $x (i32.rem_u (get_local $i) (i32.const 256)))
        (local.set $y (i32.div_u (get_local $i) (i32.const 256)))

        ;; Fun plasma-like pattern (you can change this!)
        ;; R = (x + time) % 256
        ;; G = (y + x)   % 256
        ;; B = (y * 2)   % 256
        (i32.store8 (get_local $ptr)      (i32.add (get_local $x) (i32.const 100)))  ;; R
        (i32.store8 (i32.add (get_local $ptr) (i32.const 1))
                    (i32.xor (get_local $x) (get_local $y)))                        ;; G
        (i32.store8 (i32.add (get_local $ptr) (i32.const 2))
                    (i32.mul (get_local $y) (i32.const 2)))                         ;; B
        (i32.store8 (i32.add (get_local $ptr) (i32.const 3)) (i32.const 255))        ;; A = full opacity

        ;; Advance pointer by 4 bytes (RGBA)
        (set_local $ptr (i32.add (get_local $ptr) (i32.const 4)))
        (set_local $i   (i32.add (get_local $i)   (i32.const 1)))
        (br 0)
      )
    )

    ;; Return pointer to pixel data (offset 0)
    (i32.const 0)
  )
)
</pre>

<script>
// Run this example automatically when the page loads
document.addEventListener("DOMContentLoaded", async () => {
  if (!document.getElementById("pixelCanvas")) return;

  const canvas = document.getElementById("pixelCanvas");
  const ctx = canvas.getContext("2d");
  const imageData = ctx.createImageData(256, 256);

  const wasmCode = document.querySelector("#wasm_output_ex2 pre").textContent.trim();
  const module = await inlineWebAssembly(wasmCode);  // from your bundle.js

  // Fill the buffer with colorful pixels
  module.drawPixels();

  // Copy WASM linear memory → ImageData
  const pixels = new Uint8ClampedArray(module.memory.buffer, 0, 256*256*4);
  imageData.data.set(pixels);
  ctx.putImageData(imageData, 0, 0);
});
</script>

    <!-- Example 3 -->
    <h2>Call a JS function</h2>
    <div class="owasm" id="wasm_output_ex3"></div class="owasm">
    <pre>
    ;;wasm
    (module
        (import "env" "sayHey" (func $sayHey))
        (func (export "hello")
            (call $sayHey)
        )
    )      
    
    // define the JS function
    const sayHey = function () {
        // whatever
    }

    // in JS call it with:
    const iw = require('inline-webassembly');
    const wasm = `;;wasm
        your wasm code here
    `;
    iw(wasm, { env: { sayHey } }).then((wasmModule) => {
        wasmModule.hello(); // Hey!
    });
    </pre>

    <!-- Example 4 -->
    <h2>Reverse a string</h2>
    <div class="owasm" id="wasm_output_ex4"></div>
    <pre>
    ;;wasm
    (module
        (memory $0 1)
        (export "memory" (memory $0))
        ;; declaring and exporting a function named "reverse"
        ;; it takes two arguments, the pointer to a string and its length
        ;; and it returns a 32 bit integer which is going to be the pointer
        ;; to the reversed string
        (func (export "reverse") (param $sref i32) (param $slen i32) (result i32)
 
            ;; declaring new variable to store result pointer
            (local $result i32)
 
            ;; seclaring iterator variable
            (local $iterator i32)
 
            ;; write pointer
            (local $write_to i32)
 
            ;; setting $result = $sref + $slen + 1
            (set_local $result
                ;; adding 1
                (i32.add
                    ;; adding the string pointer with its length
                    (i32.add
                        (get_local $sref)
                        (get_local $slen)
                    )
                    (i32.const 1)
                )
            )
            
            ;; setting iterator to 0, for the following loop
            (set_local $iterator
                (i32.const 0)    
            )
 
            ;; we'll start writing to the start of the result
            (set_local $write_to
                (get_local $result)    
            )
                
            (block
                (loop
                    
                    ;; store one character from original string to resulting string
                    (i32.store
                        (get_local $write_to)
                        ;; load 1 byte and sign-extend i8 to i32
                        (i32.load8_s
                            (i32.sub
                                (i32.sub
                                    (i32.add
                                        (get_local $sref)
                                        (get_local $slen)
                                    )
                                    (get_local $iterator)
                                )
                                (i32.const 1)
                            )
                        )    
                    )
 
                    ;; increment position to write to on next loop iteration
                    (set_local $write_to
                        (i32.add
                            (get_local $write_to)
                            (i32.const 1)    
                        )    
                    )
 
                    ;; increment iterator by 1 for every loop iteration
                    (set_local $iterator
                        (i32.add
                            (get_local $iterator)
                            (i32.const 1)    
                        )    
                    )
                    
                    ;; break loop if iterator reaches string length
                    (br_if 1
                        (i32.ge_s
                            (get_local $iterator)
                            (get_local $slen)
                        )
                    )
                    
                    ;; repeat loop
                    (br 0)
                )
            )
 
            ;; returning result which contains pointer to the reversed string
            (get_local $result)
        )
    )        

    // in JS call it with:
    const iw = require('inline-webassembly');
    const wasm = `;;wasm
        your wasm code here
    `;
    iw(wasm).then((wasmModule) => {
        const inputString = `Web Assembly is Cool!`;
        const stringToReverse = wasmModule.createString(inputString);
        const resultPointer = wasmModule.reverse(stringToReverse, inputString.length);
        const resultString = wasmModule.readString(resultPointer);
    });
    </pre>

    <!-- our bundled js via browserify add.js helloworld.js calljs.js stringreverse.js -o build/bundle.js -->
    <script src="build/bundle.js"></script>
</body>

</html>
