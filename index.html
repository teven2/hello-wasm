<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WASM Example</title>
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <link href="https://fonts.googleapis.com/css?family=Aldrich&display=swap" rel="stylesheet">
    <link href="styles.css" type="text/css" rel="stylesheet" media="screen" />
</head>

<body>
    <h1>WASM Examples</h1>
    <p>
        This is a small collection of <strong>wasm</strong> examples.
        Check out the console for output, as well as the div elements beneath each example
        (results loaded in these elements)
    </p>

    <!-- Example 1 -->
    <h2>Add two integers</h2>
    <div class="owasm" id="wasm_output_ex1"></div>
    <pre>
    ;;wasm
    (module
        (func (export "add") (param $n1 i32) (param $n2 i32) (result i32)
            get_local $n1
            get_local $n2
            i32.add
        )
    )     
    
    // in JS call it with:
    const iw = require('inline-webassembly');
    const wasm = `;;wasm
        your wasm code here
    `;
    iw(wasm).then((wasmModule) => {
        const sum = wasmModule.add(1, 2);
    });
    </pre>

<!-- Example 2 - Pure WASM Animated Moving Square (MAX FPS Software Rendering) -->
<h2>2. WASM-Animated Moving Square • 256×256 • Pure Software Rasterizer</h2>
<div class="owasm" id="wasm_output_ex2" style="width:256px; height:256px; image-rendering:pixelated; margin:1rem 0;">
  <canvas id="pixelCanvas" width="256" height="256" style="width:100%; height:auto; border:2px solid #58a6ff; border-radius:8px; background:#000;"></canvas>
</div>

<pre>;;wasm
(module
  (memory (export "memory") 2)  ;; 128 KiB → 256×256×4 RGBA exactly fits

  (global $time (mut f32) (f32.const 0.0))

  (func (export "updateAndRender") (param $delta f32) (result i32)
    ;; Accumulate time (in seconds)
    (global.set $time (f32.add (global.get $time) (get_local $delta)))

    (local $t f32)
    (local $i i32)
    (local $x i32)(local $y i32)
    (local $px i32)(local $py i32)

    ;; Clear framebuffer to dark space
    (memory.fill (i32.const 0) (i32.const 0xFF000020) (i32.const 262144))  ;; 256*256*4, dark blue

    ;; Smooth horizontal oscillation: pos = 128 + 80 * sin(time * 2.5)
    (set_local $t (f32.mul (global.get $time) (f32.const 2.5)))
    (set_local $t (f32.sin (get_local $t)))
    (set_local $t (f32.mul (get_local $t) (f32.const 80.0)))
    (set_local $centerX (i32.trunc_f32_s (f32.add (get_local $t) (f32.const 128.0))))

    ;; Draw 48×48 bright cyan square with glowing edge
    (set_local $size (i32.const 48))
    (set_local $half (i32.div_u (get_local $size) (i32.const 2)))

    (set_local $y (i32.sub (i32.const 128) (get_local $half)))  ;; centered Y

    (block (loop
      (br_if 1 (i32.ge_u (get_local $y) (i32.add (i32.const 128) (get_local $half))))

      (set_local $x (i32.sub (get_local $centerX) (get_local $half)))

      (block (loop
        (br_if 1 (i32.ge_u (get_local $x) (i32.add (get_local $centerX) (get_local $half))))

        ;; Distance from edge for glow effect
        (set_local $dx (i32.sub (get_local $x) (i32.sub (get_local $centerX) (get_local $half))))
        (set_local $dy (i32.sub (get_local $y) (i32.sub (i32.const 128) (get_local $half))))
        (set_local $dist (i32.add (get_local $dx) (get_local $dy)))
        (set_local $dist (i32.and (get_local $dist) (i32.const 7)))  ;; cheap fade

        (if (i32.eq (get_local $dist) (i32.const 0))
          (then
            ;; Core: full white
            (i32.store (i32.add (i32.mul (i32.add (i32.mul (get_local $y) (i32.const 256)) (get_local $x)) (i32.const 4)) (i32.const 0))
                       (i32.const 0xFFFFFFFF))
          )
          (else
            ;; Glow: cyan → blue fade
            (set_local $intensity (i32.sub (i32.const 255) (i32.mul (get_local $dist) (i32.const 36))))
            (i32.store (i32.add (i32.mul (i32.add (i32.mul (get_local $y) (i32.const 256)) (get_local $x)) (i32.const 4)) (i32.const 0))
                       (i32.or (i32.shl (get_local $intensity) (i32.const 16))
                               (i32.or (i32.shl (get_local $intensity) (i32.const 8))
                                       (i32.const 0xFF0000FF))))
          )
        )

        (set_local $x (i32.add (get_local $x) (i32.const 1)))
        (br 0)
      ))

      (set_local $y (i32.add (get_local $y) (i32.const 1)))
      (br 0)
    ))

    (i32.const 0)  ;; pointer to pixel data
  )
)
</pre>

<script>
document.addEventListener("DOMContentLoaded", async () => {
  const canvas = document.getElementById("pixelCanvas");
  const ctx = canvas.getContext("2d");
  const imageData = ctx.createImageData(256, 256);
  const wasmCode = document.querySelector("#wasm_output_ex2 pre").textContent.trim();

  const module = await inlineWebAssembly(wasmCode);

  let lastTime = performance.now() / 1000;

  function animate() {
    const now = performance.now() / 1000;
    const delta = now - lastTime;
    lastTime = now;

    module.updateAndRender(delta);  // All animation math + pixel filling in WASM!

    const buffer = new Uint8ClampedArray(module.memory.buffer, 0, 262144);
    imageData.data.set(buffer);
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(animate);
  }

  animate();
});
</script>

    <!-- Example 3 -->
    <h2>Call a JS function</h2>
    <div class="owasm" id="wasm_output_ex3"></div class="owasm">
    <pre>
    ;;wasm
    (module
        (import "env" "sayHey" (func $sayHey))
        (func (export "hello")
            (call $sayHey)
        )
    )      
    
    // define the JS function
    const sayHey = function () {
        // whatever
    }

    // in JS call it with:
    const iw = require('inline-webassembly');
    const wasm = `;;wasm
        your wasm code here
    `;
    iw(wasm, { env: { sayHey } }).then((wasmModule) => {
        wasmModule.hello(); // Hey!
    });
    </pre>

    <!-- Example 4 -->
    <h2>Reverse a string</h2>
    <div class="owasm" id="wasm_output_ex4"></div>
    <pre>
    ;;wasm
    (module
        (memory $0 1)
        (export "memory" (memory $0))
        ;; declaring and exporting a function named "reverse"
        ;; it takes two arguments, the pointer to a string and its length
        ;; and it returns a 32 bit integer which is going to be the pointer
        ;; to the reversed string
        (func (export "reverse") (param $sref i32) (param $slen i32) (result i32)
 
            ;; declaring new variable to store result pointer
            (local $result i32)
 
            ;; seclaring iterator variable
            (local $iterator i32)
 
            ;; write pointer
            (local $write_to i32)
 
            ;; setting $result = $sref + $slen + 1
            (set_local $result
                ;; adding 1
                (i32.add
                    ;; adding the string pointer with its length
                    (i32.add
                        (get_local $sref)
                        (get_local $slen)
                    )
                    (i32.const 1)
                )
            )
            
            ;; setting iterator to 0, for the following loop
            (set_local $iterator
                (i32.const 0)    
            )
 
            ;; we'll start writing to the start of the result
            (set_local $write_to
                (get_local $result)    
            )
                
            (block
                (loop
                    
                    ;; store one character from original string to resulting string
                    (i32.store
                        (get_local $write_to)
                        ;; load 1 byte and sign-extend i8 to i32
                        (i32.load8_s
                            (i32.sub
                                (i32.sub
                                    (i32.add
                                        (get_local $sref)
                                        (get_local $slen)
                                    )
                                    (get_local $iterator)
                                )
                                (i32.const 1)
                            )
                        )    
                    )
 
                    ;; increment position to write to on next loop iteration
                    (set_local $write_to
                        (i32.add
                            (get_local $write_to)
                            (i32.const 1)    
                        )    
                    )
 
                    ;; increment iterator by 1 for every loop iteration
                    (set_local $iterator
                        (i32.add
                            (get_local $iterator)
                            (i32.const 1)    
                        )    
                    )
                    
                    ;; break loop if iterator reaches string length
                    (br_if 1
                        (i32.ge_s
                            (get_local $iterator)
                            (get_local $slen)
                        )
                    )
                    
                    ;; repeat loop
                    (br 0)
                )
            )
 
            ;; returning result which contains pointer to the reversed string
            (get_local $result)
        )
    )        

    // in JS call it with:
    const iw = require('inline-webassembly');
    const wasm = `;;wasm
        your wasm code here
    `;
    iw(wasm).then((wasmModule) => {
        const inputString = `Web Assembly is Cool!`;
        const stringToReverse = wasmModule.createString(inputString);
        const resultPointer = wasmModule.reverse(stringToReverse, inputString.length);
        const resultString = wasmModule.readString(resultPointer);
    });
    </pre>

    <!-- our bundled js via browserify add.js helloworld.js calljs.js stringreverse.js -o build/bundle.js -->
    <script src="build/bundle.js"></script>
</body>

</html>
