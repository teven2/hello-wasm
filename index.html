<!DOCTYPE html>
<html>
<head>
<title>Wasm Animation Example</title>
</head>
<body>
  <canvas id="c" width="256" height="256"></canvas>

  <!-- WebAssembly Text Module -->
  <script type="text/wat">
  (module
    (memory (export "mem") 1)
    (global $frame_counter (mut i32) i32.const 0)
    (global $CANVAS_SIZE i32 (i32.const 65536)) ;; 256 * 256 pixels

    ;; Function to update the frame and return the new color
    (func (export "update_frame") (result i32)
      (local $color i32)
      (local $i i32)
      (local $current_count i32)

      ;; Increment and store frame counter
      global.get $frame_counter
      i32.const 1
      i32.add
      global.set $frame_counter

      ;; Calculate a new color based on the frame counter (e.g., a simple pulse)
      global.get $frame_counter
      i32.const 64
      i32.rem_u ;; cycle every 64 frames
      i32.const 4 ;; scaling factor for color change
      i32.mul
      local.set $color ;; $color ranges from 0 to 255

      ;; Combine $color into an RGBA format (ABGR in little-endian wasm memory)
      ;; Use a simple color like pulsing red: 0xFF<color>0000 (AARRGGBB)
      i32.const 0xFF000000 ;; Alpha (fully opaque) and other channels zero
      local.get $color
      i32.shl ;; Shift color value to the green channel position
      local.set $color
      i32.const 0xFF000000 ;; Full alpha
      local.get $color
      i32.or
      local.set $color


      ;; Fill memory with the new color
      (loop
        local.get $i
        local.get $color
        i32.store (local.get $i) ;; Store 4 bytes at once (i32)

        local.set $i (i32.add (local.get $i) (i32.const 4))
        global.get $CANVAS_SIZE
        i32.const 4
        i32.mul ;; loop up to 256 * 256 * 4 bytes
        br_if 0 (i32.lt_u (local.get $i) (i32.const 262144))
      )
      local.get $color ;; Return the color used for demonstration
    )
  )
  </script>

  <!-- JavaScript glue code for animation loop -->
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    WebAssembly.instantiate(document.querySelector('script[type="text/wat"]').textContent, {})
      .then(obj => {
        const exports = obj.instance.exports;
        const mem = exports.mem;
        const memorySize = width * height * 4; // 256*256*4 bytes

        function renderLoop() {
          // 1. Update pixel data in wasm memory
          exports.update_frame();

          // 2. Create ImageData from the shared Wasm memory
          // The buffer view must be inside the loop to see the updated data
          const memBuffer = new Uint8ClampedArray(mem.buffer, 0, memorySize);
          const imageData = new ImageData(memBuffer, width, height);

          // 3. Put the new image data onto the canvas
          ctx.putImageData(imageData, 0, 0);

          // 4. Request the next frame
          window.requestAnimationFrame(renderLoop);
        }

        // Start the animation loop
        window.requestAnimationFrame(renderLoop);
      });
  </script>
</body>
</html>
